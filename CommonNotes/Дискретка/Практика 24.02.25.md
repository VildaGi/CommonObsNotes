>[!info] Взвешенный граф
>Пусть G=(V, E) - граф, он назва-ся взвешенным, если задана функция f: E -> R(+)
>f(e) - вес ребра.
>f(E) - вес графа G.

>[!info] Остовное дерево
>Пусть G=(V, E) - граф, 
>Подграф T графа G, наз-ся остовным деревом, если выполнены 2 условия:
>1) T - дерево.
>2) T - остовный подграф.

### Алгоритм нахождение минимального оставного дерева
#### Алгоритм Краскала
Описание:
1) В начальный момент выбираем пустой остовный подграф.
2) Среди всех ребер, добавление которых к подграфу не вызовет появление цикла, выбираем ребро наименьшего веса и добавляем к подграфу.
3) если таких ребер нет, то подграф - минимальное остовное дерево.

#### Алгоритм Прима
Описание:
1) В начальный момент выбираем 1 вершину. Эта вершина дерево (на 1 вершине).
2) Среди всех ребер 1 из вершин которых принадлежит дереву, а другая нет, выбираем ребро наименьшего веса, это ребро и вершину добавляем нашему дереву.
3) если таких ребер нет, то подграф - минимальное остовное дерево.

#### Алгоритм Борувки
Описание:
1) В начальный момент выбираем пустой остовный подграф. (n компонент связанности)
2) Для каждой компоненты связанности выбираем ребро связывающие эту компоненту с другой, минимального веса. Добавляем все ребра к подграфу (Если несколько ребер связывают 2 компоненты, то выбираем только 1 ребро).
3) если компонента 1, то она минимальное остовное дерево.
### Алгоритмы нахождение кратчайшего пути
Задача: Для взвешенного графа G=(V,E) найти кратчайшие пути из вершины v in V до всех оставшихся вершин.
#### Алгоритм Дейстры (для графов без отрицательных ребер)
описание алгоритма:
	1) в начальный момент устанавливаем метку вершину v в 0, у остальных вершин метка: бесконечность. Все вершины не посещены.
	2) среди непосещенных вершин выбираем вершину w с наименьшей меткой. Для всех смежных с w вершин вычисляем сумму метки w и веса ребра из w в эту вершину. Если это значение меньше метки вершины, то меняем метку на это значение. Делаем w посещенной.
	3) Если все вершины посещены, то метки и есть кратчайшие пути из вершины w.

Пример + решение:
![[примерГрафа_1.png]]
	1) Расставляем метки:![[Pasted image 20250224114336.png]]
	2) выбираем 1 как начало.
	3) ![[Pasted image 20250224114500.png]]
	4) ![[Pasted image 20250224114615.png]]
	5) ![[Pasted image 20250224114701.png]]
	6) ![[Pasted image 20250224114730.png]]Ничего не изменилось, потому вершину 2 делаем посещенной. По аналогии 5 вершина также, как и 6.
	7) ![[Pasted image 20250224114845.png]]Решение, где метки(зеленые числа) это кратчайшие пути.

Для сохранение пути, мы к 2 пункту добавляем:
Для вершин, у которых мы изменили метку, мы сохраняем вершину, которая изменила этот вес.


#### Алгоритм Флойда
(можно использовать на графе с отриц. ребрами, но без отриц. циклов)
Описание алгоритма:
	Пусть в графе G - n вершин и пусть эти вершине пронумерованы от 1 до n. Тогда граф G задаем матрицей смежностей A(n\*n), a_ij =
	   0 - если i = g.
	   бесконечность - если не смежны.
	   вес ребра - иначе.
	Определим (a_ij)^k = кратчайший путь из i в j и промежуточными вершинами с номерами не больше k.
	(a_ij)^0 - обычная a_ij
	A = A^0 -> A^1 -> ... -> A^n 	 
	(a_ij)^k = min( (a_ij)^k-1,  (a_ik)^k-1 +  (a_kj)^k-1)

Решение:
делаем матрицу:          
|  0  6  2 -1 -1 -1 |         |  0  6  2 -1 -1 -1 |   
|  6  0  3  1 -1 -1 |         |  6  0  3  1 -1 -1 | 
|  2  3  0  1  5 -1 |          |  2  3  0  1  5 -1 |
| -1 -1 1  0  3  4 |    ->  | -1 -1 1  0  3  4 | --> ..... в падлу думать
| -1 -1 5  3  0  5 |          | -1 -1 5  3  0  5 |
| -1 -1- 1 4 5  0 |           | -1 -1- 1 4 5  0 |
                  (ничего не изменилось)

